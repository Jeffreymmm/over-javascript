## 一 网络安全传输

### 1.1 SSL 简介

传统的网络传输中，内容都是以明文形式传输，安全性很低。而对于 HTTP、FTP 协议而言，我们同样希望其本身只是负责数据的传输而不是加密解密。SSL 是当年的网景公司（火狐的前身）退出的安全协议，它会在传输层提供对网络连接的加密功能。对于应用程序而言，数据在传递到应用层之前就已经完成了加密、解密的过程。SSL 经过标准化后，称呼为 TLS。

HTTPS 即 SSL 和 HTTP 结合产物，WSS 即 SSL 和 WebSocket 结合的产物。

当然 HTTPS 由于引入了加密解密过程，而且这种加密机制使用的是非对称加密，其算法性能很低，所以 HTTPS 也因此牺牲了很大一部分性能。

### 1.2 SSL 实现

不同的 SSL 握手过程存在差异，分为以下三种：

- 只验证服务器
- 验证服务器和客户端
- 恢复原有会话

这里只介绍第一种过程。

**第 1 步**：客户端发送一个消息给服务端

```
客户端发送Client Hello消息。
该消息包括SSL版本信息，一个随机数（假设它是random1）、一个session id(用来避免后续请求的握手)和浏览器支持的密码套件（cipher suite）。
cipher suite是由加密算法名称组成的字符串，包括了4种用途的加密算法：密钥交换算法（RSA等）、数据加密算法（AES256等）、报文认证信息码（MAC）算法（MD5、SHA等）、伪随机数（PRF算法）
cipher suite字符串示例：TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256
```

**第 2 步**：服务器对消息进行验证，服务器确定本次通信使用的 SSL 版本和其他信息，发送 Server Hello 给客户端。Server Hello 里面的内容包括服务器支持的 SSL 版本信息，一个伪随机数（假设它是 random2）、服务器的密码套件（cipher suite）。

**第 3 步**：服务器发送 CA 证书给客户端

**第 4 步**：服务器发送 Server Hello done

**第 5 步**：客户端验证服务器证书的合法性后(Certificate Verify)后，利用证书中的公钥加密 premaster secret(一个在堆成加密密钥生成中的 46 字节随机数字，以及消息认证代码)作为 Client Key Exchange 的消息发送给服务器。

**第 6 步**：SSL 客户端发送 Change Cipher Spec 消息，该消息属于 SSL 密码变化协议

**第 7 步**：客户端计算历史消息的 hash 值，然后使用服务器公钥加密后发送给服务器，服务器进行同样的操作，然后两个值结果相同表示密钥交换成功

**第 8 步**：服务器发送 Change Cipher Spec 消息

**第 9 步**：服务器计算历史消息的 hash 值，通过交换后的密钥加密，将其作为 finished 消息发送给客户端，客户端利用交换后的密钥解密，如果和本地历史消息相同就黄泽宁服务器身份，握手结束

### 1.3 密钥交换步骤

无论加密数据使用的是非对称加密还是对称加密，客户端和服务器都要交换密钥：

- 对称加密：又称为私钥加密或者会话密钥加。客户端需要将解密的密钥发送给服务器。发送方和接收方使用同一个密钥去加密解密数据，速度较快。
- 非对称加密：又称公钥密钥加密。需要把自己的私钥发给对方。使用不同的密钥来分别完成加密和解密操作，一个公开发布，即公钥，一个用户自己保存，即私钥。信息发送者用公钥去加密，信息接收者使用私钥

常见的密钥交换算法是 RSA 算法，是一种非对称加密算法，步骤如下：

- 步骤 1：Client Verify。客户端接收到服务端传来的整数后，先验证该证书合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 random3，再用服务端公钥加密 random3 生成 PreMasterKey
- 步骤 2：Clent Key Exchange：将第一步最后生成的 key 传给服务端，服务端用自己的私钥解出这个 key，得到客户端生成的 random3，再加上 random1，random2，至此，客户端和服务端都拥有了 random1，random2，random3.

两边再根据同样的算法就可以生成一份密钥，握手结束后应用层数据都是用该密钥进行对称加密，使用三个随机数的原因是提升暴力破解难度。

### 1.4 CA 证书与中间人攻击

上述的步骤就像两个同学上课传纸条，二人为了不让其他人发现纸条的信息，互相约定了写法和破译，各自的加密内容只有自己的解密办法才能破译，那么在传输信息前需要双方交换自己的加方法（公钥）。

然而在第一次交换加密方法的纸条传递时，中间负责传递的同学把交换双方的公钥都换成了自己伪造的公钥，那么就可以轻松使用自己的私钥读取她们的通信内容，这就是中间人攻击。

CA 是第三方组织，用来验证证书合法性，即在上述案例中，纸条由互相信任的班主任传递。

## 二 创建证书

制作公钥与私钥：

```
# 生成服务端私钥
openssl genrsa -out server.key 1024

# 生成服务端公钥
openssl rsa -in server.key -pubout -out server.pem

# 生成客户端私钥
openssl genrsa -out client.key 1024

# 生成客户端公钥
openssl rsa -in client.key -pubout -out client.pem
```

公钥和私钥仍然不能完全预防破解、窃听的可能，典型的例子是中间人攻击。客户端和服务端在交换公钥的过程中，中间人对客户端扮演服务端角色，对服务端扮演客户端角色，客户端和服务端就不再感受到有中间人的存在。为了解决这个问题，数据传输还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器！这便是数字认证，一般使用第三方数字证书颁发机构 CA 制作的证书，这个证书中具有 CA 通过自己的刚要和私钥实现的签名。

为了得到签名证书，服务端需要通过自己的私钥生成 CSR 证书签名请求文件，CA 机构通过该文件办法属于该服务端的签名证书，只要通过 CA 机构就能验证证书是否合法。

通过 CA 机构办法证书相当复杂耗时，中小企业一般采用自签名来构建安全网络，就是自己扮演 CA 机构，给自己的服务端办法签名证书，下面步骤即是制作扮演 CA 角色需要的文件：

```
openssl genrsa -out ca.key 1024
openssl req -new -key ca.key -out ca.csr
openssl x509 -req -in ca.csr -signkey ca.key -out ca.crt
```

服务端此时需要向 CA 机构申请签名证书，在申请前要创建自己的 CSR 文件（Common Name 要匹配服务器域名）：

```
openssl req -new -key server.key -out server.csr
```

得到 CSR 文件后，向自己的 CA 机构申请签名：

```
openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -in server.csr -out server.crt
```

客户端在发起安全连接前先回去获取服务端的证书，通过 CA 的证书验证服务端证书、服务器名称、服务器 IP 的真伪，如下图所示：

![](../images/node/04-06.png)

CA 机构将证书颁发给服务端后，证书在请求过程中会被发送给客户端，客户端需要通过 CA 的证书验证真伪，如果是知名的 CA 机构，它们的证书一般会预装在浏览器中，如果是自己扮演的 CA 机构，颁发自有签名则没有该福利！！

注意：签名证书是一环一环的颁发的，但是在 CA 那里的证书是不需要上级证书参与签名的，这个证书通常称为根证书。
