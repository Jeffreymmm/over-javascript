## 一 TCP/IP 协议簇

### 1.1 网络分层

TCP/IP 协议簇是一系列网络相关协议的总称，其典型特征是分为四层结构：

- 应用层：HTTP 协议、FTP 协议等。一般是开发者编写的应用程序，直接为用户提供服务，通过系统调用和传输层进行通信。
- 传输层：TCP 协议、UDP 协议等。传输层通过系统调用向应用层提供两台计算机之间输出传输能力。
- 网络层：IP 协议。网络层用来处理网络上流动的数据报，规定通过怎样的路径到达对方计算机，并将数据报传输给对方。
- 链路层：硬件相关，也称呼为网络接口层，用来处理连接网络的硬件部分。

### 1.2 数据封包、解包

数据在网络传输时，是需要经过封包、解包的过程的。数据在经过应用程序发送时，封包的过程如下所示：

![](../images/net/net-01.png)

在封包时候，数据沿着协议栈，不断的在各个层加上头部信息，链路层还会额外加入尾部信息。最终数据到达互联网后，就具备了所有需识别的信息。

解包即是数据从下层传输到上层时，会逐层把下层的头部信息删除：

![](../images/net/net-02.png)

### 1.3 TCP 三次握手

传输层的协议常见的有 TCP、UDP 两种。UDP 是无连接的，性能高，但是不可靠。TCP 是面向连接的，损失了一定的性能，但是更加可靠。

所谓的可靠性是指在数据传输前，发送端、接收端先互相进行验证对方的收发功能是否正常！TCP 中的验证方式是三次握手、四次挥手。

![](../images/net/net-03.png)

三次握手过程：

- 第一次握手：客户端发送请求报文段，内部包含 SYN 标志，发送后进入 SYN_SEND 状态，等待服务端确认
- 第二次握手：服务端接收到客户端 SYN 报文后，发送 ACK 信息对这个 SYN 报文段进行确认，同时额外发送自己的 SYN 请求信息，发送后进入 SYN_RECV 状态
- 第三次握手：客户端接收到服务端的 SYN+ACK 报文后，会向服务端发送 ACK 确认报文段，发送完毕后，客户端和服务端都会进入 ESTABLISHED 状态，三次握手完成，开始进行真实数据传输！

三次握手具体流程图：  
![](../images/net/net-04.png)

四次挥手过程

- 四次挥手：关闭传输时，额外进行的依次握手

## 二 网页的访问

服务器地址都是以 IP 的形式进行标识的，那么在浏览器中却无需直接输入 IP 地址，而是输入网址就可以访问对方服务器，这是因为有 DNS 的帮助。

DNS 服务就是用来提供域名到 IP 地址之间的转换解析服务的！

![](../images/net/net-05.png)

为了提升效率，DNS 服务是有缓存的，依照就近原则，来进行网址与 IP 的解析，当访问一个网址时：

- 优先从本地 host 文件中查找 ip 地址
- 然后查找本地的 DNS 缓存服务
- 去 DNS 服务商中查找

所以一个请求的真实访问过程如下所示：

![](../images/net/net-06.png)

## 三 关于网址

URI：是一个紧凑的字符串，用来表示抽象、物理资源，可以分为 URL、URN，类似 URN 作用类似一个人的名字（身份），URL 类似一个人的地址（位置 ）。

URL 是 URI 的一种，但不是所有的 URI 都是 URL，访问机制决定了他们的不同，有访问机制的 URI 才是 URL，示例如下：

- URL：`ftp://ftp.down/1.txt`
- URI：`tel:+1-010-11-1311`

## 四 HTTP 协议

HTTP 协议是 TCP/IP 协议的一个子集，是超文本传输协议，在该协议规范下，允许将超文本标记语言 HTML 文档从 web 服务器传送到客户端（浏览器）。

包含的方法有：

- GET:默认的方法，用来请求已经被 URI 识别的资源
- POST:与 GET 类似，但是一般用来传输实体的主题，其目的不是为了获取响应主体内容，而是一般用于提交大批量的表单数据
- PUT:与 POST 类似，但是 PUT 是幂等的（多次重复造作结果一致），POST 不是幂等的，所以 PUT 一般用于更新数据 ！
- HEAD:只用于获取报头，所以可以用来测试链接的有效性
- DELETE:用于删除资源，与 PUT 相反或者说对应
- OPTIONS:用来查询针对请求 URI 的资源的方法是否支持
- TRACE:回显服务器收到的请求，用于测试、诊断
- CONNECT:开启客户端与服务端资源之间的通道

HTTP 请求的结果用状态码来表示请求的结果：

- 1xx：表示消息，代表请求被接受，需要继续处理，是一种临时响应
- 2xx：表示成功。
  - 200：OK，请求成功，处理成功
  - 202：Accepted，请求已接受，但是处理未完成
  - 206：Partial Content，部分请求被处理完成。断点续传中会用到。
- 3xx：表示重定向，代表客户端采取进一步操作才能完成请求，后续的请求地址（重定向目标）在本次响应的 Location 域中指明
  - 301：Moved Permanently，永久重定向，请求的资源被永久移动到了新 URI
  - 302：Found，临时移动，客户端后续请求应该继续使用原有 URI
- 4xx：表示请求错误。
  - 400：Bad Request，客户端请求语法错误，服务器无法理解
  - 401：Unauthorized，请求要求用户的身份认证
  - 403：Forbidden，服务器理解了客户端的请求，但是拒绝执行，
  - 404：Not Found，服务器未找到对应资源
- 5xx：表示服务器错误。
  - 500：Internal Server Error，服务器内部错误，请求无法完成
  - 502：Bad Gateway，网关或者代理服务器收到了无效请求

## 五 内容协商机制

内容协商机制：客户端和服务端就响应的资源内容进行交涉，以提供最适合当前客户端需求的资源。比如给英语地区的客户端显示英语界面，给汉语地区的客户端显示汉语界面。

内容协商一般以响应资源的语言、字符集、编码等方式作为判断基准。

协商方式有：

- 客户端驱动：客户端发送请求，服务端返回可选列表，客户端做出选择后发送二次请求
- 服务端驱动：客户端发送请求，服务端 根据请求头部集，直接判断选择哪个版本的页面。该方式使用较为广泛。
  - 常用判断头部：Accept，Accept-Language、Accpet-Charset、Accept-Encoding
  - 常用判断头部：Content-Type，Content-Language
- 透明协商：某个中间设备（通常是缓存代理）代表客户端进行协商

## 六 HTTPS

Http 在网络中是以明文形式传输的，其安全性极差，HTTPS 就是为了解决 HTTP 安全性问题而诞生的。

HTTPS 其本质仍然是基于 http 协议，在此基础上增加了 TLS 传输层加密协议（前身是 SSL 协议），所以 HTTPS 可以简单理解为：

```
HTTPS = HTTP + TLS
```

## 七 HTTP 的瓶颈

HTTP 协议已经很古老，目前广泛使用的 HTTP 协议版本为 http1.1，该版本支持缓存处理、长连接、请求流水线处理等，但是仍然不符合当前 4G、5G 的发展。

http2.0 在性能上有了大幅提升，特点如下：

- 基于二进制格式进行数据解析，性能极高。http1.1 是基于文本的。
- 多路复用：连接是共享的，每一个 request 都是用作连接共享机制的，一个 req 对应一个 id，接收方根据 id 归属到不同的服务端请求里。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升
- header 压缩：通讯双方各自缓存一份 header fields 表，避免 header 的重复传输，减小传输文件大小。而 http1.1 则每次请求都附带大量的 header 信息
- 服务端推送：即支持从服务端主动推送信息给客户端

HTTP2.0 中的多路复用和 HTTP1.1 中的长连接复用区别：

```
HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；
HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；
HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
```

![](../images/net/net-07.png)

## 八 WebSocket
